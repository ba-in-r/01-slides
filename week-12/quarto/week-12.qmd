---
title: "Unidad 8 ‚Äî An√°lisis de Canasta de Mercado"
subtitle: "Semana 12: Reglas de Asociaci√≥n"
author: "Eduard F. Mart√≠nez Gonz√°lez"
---

<a href="mailto:efmartinez@icesi.edu.co" style="color:black;">
<img src="pic/correo.png" alt="Email" width="20" height="20"/> efmartinez@icesi.edu.co
</a>

<a href="https://github.com/eduard-martinez" style="color:black;"> <img src="pic/github.png" alt="Qries" width="20" height="20"/> eduard-martinez</a>

<a href="https://twitter.com/emartigo" style="color:black;"> <img src="pic/twitter.jpg" alt="Qries" width="20" height="20"/> @emartigo</a>

<a href="https://eduard-martinez.github.io" style="color:black;"> <img src="pic/link.png" alt="Qries" width="20" height="20"/> https://eduard-martinez.github.io</a>

# An√°lisis de Canasta de Mercado

El **an√°lisis de canasta de mercado** (Market Basket Analysis) es un conjunto de t√©cnicas de **miner√≠a de datos** utilizadas para descubrir asociaciones entre productos comprados por los clientes.  

Es una herramienta fundamental en **retail analytics**, ya que permite a los minoristas identificar patrones de consumo, mejorar la disposici√≥n de productos, dise√±ar promociones cruzadas y aumentar las ventas.

## Conceptos clave

Este an√°lisis pertenece a la tarea de **asociaci√≥n**, un tipo de **aprendizaje no supervisado** que busca identificar **patrones frecuentes de co-ocurrencia** entre √≠tems dentro de transacciones (tambi√©n conocidas como *tirillas de compra* o *tickets de venta*).

- **Antecedente:** producto o conjunto de productos que provocan la compra de otros. Ejemplo: `{Leche} ‚Üí {Pan}`  

  ‚Üí Si un cliente compra leche, es probable que tambi√©n compre pan. 

- **Consecuente:** producto que resulta asociado al antecedente.  
  En el ejemplo anterior, el *pan* es el consecuente.

## Aplicaciones t√≠picas

- **Comercio minorista:** identificar productos que se venden juntos (leche y cereales).  
- **Marketing digital:** recomendaciones tipo ‚Äúlos clientes que compraron este producto tambi√©n compraron‚Ä¶‚Äù.  
- **Bancos:** detecci√≥n de co-uso de productos financieros (cuenta de ahorros + tarjeta).  
- **Streaming:** recomendaci√≥n de contenidos seg√∫n consumo conjunto.

# Aplicaci√≥n en R

Para ilustrar el **an√°lisis de canasta de mercado**, trabajaremos con un conjunto de transacciones que representa las **compras realizadas por los clientes de un supermercado** durante un periodo determinado.  
Cada transacci√≥n contiene uno o m√°s productos adquiridos en la misma compra, lo que nos permitir√° identificar **patrones de asociaci√≥n** entre ellos.

En este contexto:

- Cada **√≠tem** corresponde a un producto individual.  
- Cada **transacci√≥n** agrupa los productos comprados por un mismo cliente.  
- El objetivo es descubrir **reglas del tipo**:  
  `{Leche} ‚Üí {Pan}`  e interpreta como:  
  *‚ÄúLos clientes que compran leche y pan tienden tambi√©n a comprar mantequilla.‚Äù*

A partir de este ejercicio podremos responder preguntas como:

- ¬øQu√© productos suelen comprarse juntos con mayor frecuencia?  
- ¬øQu√© asociaciones son m√°s fuertes en t√©rminos de confianza y soporte?  
- ¬øQu√© reglas podr√≠an usarse para dise√±ar promociones o estrategias de recomendaci√≥n?

Este tipo de an√°lisis tiene m√∫ltiples aplicaciones pr√°cticas en **marketing, retail y comportamiento del consumidor**, y se basa en los mismos principios de aprendizaje no supervisado que utilizamos en t√©cnicas como clustering o an√°lisis de redes.

::: callout-tip
üí° **C√≥mo usar este material:**  
Puedes ejecutar los _chunks_ de R directamente en el navegador gracias a **webR**, sin necesidad de instalar nada localmente.
:::

## Preparaci√≥n del entorno

El prop√≥sito de este bloque es asegurar un entorno **limpio, reproducible y funcional** antes de iniciar el an√°lisis. Primero, eliminamos cualquier objeto previo que pueda interferir con la sesi√≥n actual. Luego, instalamos (si es necesario) y cargamos los paquetes requeridos para la **manipulaci√≥n de datos**, la **construcci√≥n de transacciones** y la **generaci√≥n de reglas de asociaci√≥n**. Con esto, dejamos el entorno preparado para comenzar el an√°lisis de canasta de mercado.

```{webr-r}
# Limpiar el entorno de trabajo
rm(list = ls())

# instalar
install.packages("arules")
install.packages("arulesViz")

# Cargar paquetes
library(tidyverse)   # Manipulaci√≥n y transformaci√≥n de datos
library(arules)      # Construcci√≥n y an√°lisis de redes
library(arulesViz)      # Visualizaci√≥n avanzada de grafos

# Fijar semilla para reproducibilidad
set.seed(123)
```
::: callout-note
Los paquetes `arules` y `arulesViz` pertenecen al ecosistema de data mining en R.
	‚Ä¢	`arules` permite aplicar el algoritmo Apriori, que identifica combinaciones frecuentes de productos.
	‚Ä¢	`arulesViz` facilita la visualizaci√≥n interactiva de las reglas y sus m√©tricas (soporte, confianza y lift).
:::

## Ingesta de datos 

En esta secci√≥n realizamos la **ingesta de datos**, es decir, el proceso de cargar o generar la base que utilizaremos para construir la **canasta de mercado**. Cada registro representa una **transacci√≥n individual**, es decir, el conjunto de productos que un cliente compr√≥ en una misma visita al supermercado. Nuestro objetivo ser√° analizar estos datos para descubrir **patrones de compra conjunta** y **reglas de asociaci√≥n** entre productos.

La estructura de datos es la siguiente:

- Cada **√≠tem** corresponde a un producto (por ejemplo: *Leche*, *Pan*, *Huevos*).  
- Cada **transacci√≥n** es una lista de productos comprados juntos.  

- El **conjunto de todas las transacciones** conforma la base que usaremos para aplicar el algoritmo *Apriori* y encontrar asociaciones significativas.

```{webr-r}
#| warning: false
#| message: false

## generar los datos
source("https://raw.githubusercontent.com/ba-in-r/01-slides/main/week-12/data/week-12.r")

## chuequear objeto
ventas[1:5]
```

**Interpretaci√≥n:** Cada elemento de la lista ventas representa una compra √∫nica: un conjunto de productos adquiridos por un cliente. Por ejemplo:

Esto significa que:

	‚Ä¢	En la transacci√≥n 1, el cliente compr√≥ mantequilla, pan, queso y verduras. 
	‚Ä¢	En la transacci√≥n 2, compr√≥ cereal, queso, leche, pan, mantequilla y huevos.

Esta estructura servir√° como punto de partida para convertir las listas en objetos transaccionales y aplicar el algoritmo Apriori, que nos permitir√° descubrir qu√© productos se compran juntos con mayor frecuencia.

## Conversi√≥n al formato transaccional

Antes de aplicar t√©cnicas de an√°lisis de cesta de mercado, es fundamental que los datos se encuentren en un formato adecuado para este tipo de estudio. En particular, los algoritmos de reglas de asociaci√≥n, como Apriori o Eclat, requieren que la informaci√≥n est√© organizada en formato transaccional, donde cada observaci√≥n representa una transacci√≥n individual y contiene el conjunto de √≠tems comprados conjuntamente.

Para lograr esto, se deben agrupar los productos por el identificador de la transacci√≥n (ID), de modo que cada registro muestre la lista de art√≠culos adquiridos en una misma compra o canasta. En R, esta conversi√≥n puede realizarse f√°cilmente utilizando la funci√≥n split(), que permite crear una lista de √≠tems por transacci√≥n. Posteriormente, dicha lista se transforma en un objeto de clase transactions, el cual es compatible con los paquetes de an√°lisis de asociaciones como arules.

A continuaci√≥n, verificamos la estructura del objeto `ventas` para conocer su tipo de datos y asegurarnos de que puede convertirse correctamente al formato transaccional. 

```{webr-r}
# class
class(ventas)
```
::: callout-note
En este caso, el objeto se presenta como una lista, lo que significa que cada elemento ya corresponde a una transacci√≥n (es decir, un conjunto de √≠tems comprados juntos). Por tanto, no es necesario aplicar la funci√≥n split(), ya que los datos ya est√°n organizados en el formato requerido.
:::

Una vez confirmada la estructura de los datos, procedemos a convertir el objeto ventas al formato transactions utilizando la funci√≥n as() del paquete arules.
Este paso es esencial, ya que permite representar cada lista de productos como una transacci√≥n individual dentro de un objeto especializado que puede ser interpretado por los algoritmos de reglas de asociaci√≥n.

Posteriormente, se realiza una exploraci√≥n inicial para verificar que la conversi√≥n fue exitosa y comprender las caracter√≠sticas b√°sicas del conjunto de transacciones, como el n√∫mero total de √≠tems y transacciones, as√≠ como ejemplos de las primeras canastas registradas.

```{webr-r}
# Conversi√≥n directa de la lista al formato transaccional
ventas_t <- as(ventas, "transactions")

# Resumen del objeto transaccional
summary(ventas_t)

# Visualizar las primeras transacciones
inspect(head(ventas_t, 5))
```






Con los datos agrupados ya en una lista, podemos convertirlos en una transacci√≥n, para esto, hacemos uso de la funci√≥n as() del paquete arules:

datos.tra <- as(datos.lista, "transactions")
class(datos.tra)








## Tipos de grafos

Este tipo de red solo representa la existencia de conexi√≥n entre dos jugadores, sin importar qui√©n inici√≥ el pase ni cu√°ntas veces ocurri√≥. Se usa cuando el inter√©s es identificar si existe relaci√≥n, no su direcci√≥n ni su intensidad.

```{webr-r}
## No ponderado, no dirigido
no_dir_plot <- graph.adjacency(sel_colombia, mode="undirected" , diag=FALSE)

## plot
plot(no_dir_plot)
```
Aqu√≠ se incorpora la direcci√≥n del pase, lo cual es crucial en contextos din√°micos como el f√∫tbol. Cada flecha representa qui√©n pasa y qui√©n recibe el bal√≥n.

```{webr-r}
## No ponderado, dirigido
dir_plot <- graph.adjacency(sel_colombia, mode="directed" , diag=FALSE)

## plot
plot(dir_plot, edge.arrow.size=0.8)
```

Incorporamos ahora la intensidad del pase (peso), pero tratamos la red como bidireccional: si dos jugadores se pasan el bal√≥n mutuamente, la arista representa la suma de sus interacciones.

```{webr-r}
## Ponderado, no dirigido
pond_no_dir <- graph.adjacency(sel_colombia, weighted = TRUE, mode ="undirected", diag = FALSE)

## plot
plot(pond_no_dir , edge.width=E(pond_no_dir)$weight)
```
Finalmente, representamos la red completa: cada arista tiene una direcci√≥n (qui√©n pasa a qui√©n) y un peso (frecuencia del pase). Este es el tipo de grafo m√°s informativo para analizar patrones de juego y centralidad.

```{webr-r}
## Ponderado, dirigido
pond_dir <- graph.adjacency(sel_colombia, weighted = TRUE, mode ="directed", diag = FALSE)

## plot
plot(pond_dir , edge.width=E(pond_no_dir)$weight ,  edge.arrow.size = 0.8)
```

## Indicadores de centralidad

El grafo por s√≠ solo nos permite visualizar la estructura general del equipo, pero no siempre es suficiente para analizar la influencia de cada jugador. En la pr√°ctica, las redes pueden ser densas y confusas ‚Äî las l√≠neas se sobreponen y es dif√≠cil identificar qui√©n tiene un rol central o de conexi√≥n.

Para eso, usamos los indicadores de centralidad, que cuantifican la importancia de cada nodo (jugador) dentro de la red seg√∫n diferentes criterios. Estas m√©tricas pueden dividirse en tres grupos: medidas locales, medidas globales y medidas agregadas de red.

### Medidas locales

Eval√∫an la posici√≥n de un nodo respecto a su entorno m√°s inmediato, es decir, cu√°ntos v√≠nculos tiene o qu√© tan importante es como intermediario en los flujos de interacci√≥n.

#### Grado de Centralidad (Degree Centrality)

Mide el n√∫mero de conexiones directas de cada jugador. En el contexto futbol√≠stico, un jugador con alto grado de centralidad es aquel que participa en muchas jugadas de pase.

```{webr-r}
degree(no_dir_plot, mode = "all")
```

**Interpretaci√≥n:** Los jugadores con valores m√°s altos son los que tienen mayor participaci√≥n directa en la circulaci√≥n del bal√≥n (por ejemplo, mediocampistas que conectan l√≠neas o defensas que inician las jugadas).

#### Intermediaci√≥n (Betweenness Centrality)

Mide cu√°ntas veces un nodo act√∫a como puente entre otros dos jugadores. Un jugador con alta intermediaci√≥n es esencial para mantener la cohesi√≥n del equipo: si se elimina, la red puede fragmentarse.

```{webr-r}
betweenness(no_dir_plot)
```

**Interpretaci√≥n:** Valores altos indican jugadores que canalizan el juego entre distintas zonas del campo (por ejemplo, James o Mu√±oz como conectores entre defensa y ataque).

### Medidas globales

Eval√∫an la posici√≥n de un jugador respecto a toda la red, considerando distancias, flujos y relevancia relativa dentro del equipo.

#### Cercan√≠a (Closeness Centrality)

Mide qu√© tan r√°pido un jugador puede alcanzar al resto de sus compa√±eros (en promedio). Cuanto mayor la cercan√≠a, m√°s eficiente es su acceso al resto de la red.

```{webr-r}
## Centralidad de cercan√≠a: eficiencia de conexi√≥n global
closeness(no_dir_plot, mode = "all")
```

**Interpretaci√≥n:** Los jugadores con alta cercan√≠a son aquellos que reciben y distribuyen el bal√≥n con pocos intermediarios, facilitando la fluidez del juego.

#### Puntaje de autoridad (Authority Score)

Indica la importancia relativa de un nodo considerando no solo su n√∫mero de conexiones, sino la relevancia de los nodos a los que est√° conectado. En el f√∫tbol, representa a los jugadores m√°s influyentes en el flujo del bal√≥n.

```{webr-r}
## Puntaje de autoridad: influencia relativa de cada nodo
authority.score(no_dir_plot)$vector
```

**Interpretaci√≥n:** Un puntaje alto sugiere que el jugador est√° conectado con otros importantes. En redes dirigidas, esta m√©trica suele identificar a los receptores clave de pases.

### Otras medidas complementarias

Existen tambi√©n m√©tricas que no pertenecen estrictamente a las categor√≠as anteriores, pero ayudan a describir la estructura general de la red.

#### Distancia promedio (Mean Distance)

Mide el n√∫mero medio de pasos necesarios para conectar dos jugadores cualesquiera. Cuanto menor sea la distancia, m√°s compacto y eficiente es el equipo.

```{webr-r}
## Distancia promedio entre jugadores
mean_distance(no_dir_plot)
```

#### Excentricidad (Eccentricity)

Mide la distancia m√°xima desde un jugador al m√°s lejano en la red.

```{webr-r}
## Excentricidad de cada jugador
eccentricity(no_dir_plot, mode = "all")
```

**Interpretaci√≥n:** Jugadores con alta excentricidad est√°n perif√©ricos en el juego; los de baja excentricidad son centrales o muy conectados.

### Medidas agregadas de la red

Estas m√©tricas resumen propiedades estructurales globales: cohesi√≥n, conectividad y redundancia.

#### Di√°metro (Diameter)

Mide la m√°xima excentricidad, es decir, la ruta m√°s larga que conecta dos jugadores.

```{webr-r}
## Di√°metro de la red (camino m√°s largo)
diameter(no_dir_plot)
```

#### Densidad (Density)

Es la proporci√≥n de conexiones efectivas sobre todas las posibles. Indica qu√© tan interconectado est√° el equipo.

```{webr-r}
## Crear grafo binario para medir densidad
sel_colombia_1 <- sel_colombia
for (i in 1:ncol(sel_colombia_1)) {
    for (j in 1:nrow(sel_colombia_1)) {
         sel_colombia_1[j, i] <- ifelse(sel_colombia_1[j, i] > 0, 1, sel_colombia_1[j, i])
    }
}

g_den <- graph.adjacency(sel_colombia_1, mode = "undirected",
                         weighted = NULL, diag = FALSE)

## Calcular densidad
edge_density(g_den)
```

**Interpretaci√≥n:** Una alta densidad indica un equipo cohesionado, donde la mayor√≠a de los jugadores interact√∫an entre s√≠.

### Transitividad (Transitivity)

Mide la proporci√≥n de tri√°ngulos completos en la red, es decir, cu√°ntos grupos de tres jugadores est√°n totalmente conectados.

```{webr-r}
transitivity(no_dir_plot)
```

**Interpretaci√≥n:** Alta transitividad sugiere jugadas triangulares frecuentes (asociaciones cortas y cooperaci√≥n local).

#### Reciprocidad (Reciprocity)

Indica la probabilidad de que si un jugador A le pasa a B, B tambi√©n le devuelva el pase.

```{webr-r}
reciprocity(no_dir_plot) 
```

**Interpretaci√≥n:** La reciprocidad mide la mutualidad de las interacciones, es decir, qu√© tanto los pases van en ambas direcciones (colaboraci√≥n bidireccional).

# Actividad en Clase: Red de Mensajes de WhatsApp

## Objetivo

Aplicar los conceptos de **an√°lisis de redes** vistos en clase para identificar los contactos m√°s influyentes, los intermediarios y la estructura general de comunicaci√≥n dentro de un grupo de mensajes de WhatsApp simulado.

## Instrucciones

  1. Copia y ejecuta los *chunks* de c√≥digo en R (o directamente en tu entorno webR si est√° habilitado). Esto generar√° una base de datos con los mensajes enviados entre un grupo de contactos y construir√° la matriz de adyacencia necesaria para el an√°lisis.

```{webr-r}
## generar los datos
source("https://raw.githubusercontent.com/ba-in-r/01-slides/main/week-11/data/data.r")
```

  2.	Analiza los resultados obtenidos paso a paso.

	3.	Guarda tu c√≥digo y tus respuestas en un √∫nico archivo .qmd o .html.

	4.	Sube tu archivo final a la plataforma Intu antes del cierre de la sesi√≥n.

## Preguntas

**1. Construcci√≥n del grafo:**

	‚Ä¢	Crea un grafo dirigido y ponderado a partir de la base generada (mensajes).
	‚Ä¢	Aseg√∫rate de que las aristas representen la direcci√≥n del mensaje y su frecuencia (peso).

**2. Indicadores de centralidad:**

Calcula al menos tres indicadores de centralidad:

	‚Ä¢	Grado de centralidad (Degree)
	‚Ä¢	Intermediaci√≥n (Betweenness)
	‚Ä¢	Cercan√≠a (Closeness)

**3. Visualizaci√≥n de la red**

Genera una visualizaci√≥n que muestre las relaciones entre los contactos usando:

	‚Ä¢	plot() (visualizaci√≥n b√°sica), o
	‚Ä¢	ggraph() (visualizaci√≥n avanzada con control de color y tama√±o).

**4. Entrega:** Archivo .R con c√≥digo.

Sube tu archivo a Intu con el nombre: Taller7_Apellido_Nombre.qmd
	
	