---
title: "Unidad 7"
subtitle: "Semana 11: Visualizaci√≥n y An√°lisis de Redes (Teor√≠a de Grafos)"
author: "Eduard F. Mart√≠nez Gonz√°lez"
---
  
<a href="mailto:efmartinez@icesi.edu.co" style="color:black;">
<img src="pic/correo.png" alt="Email" width="20" height="20"/> efmartinez@icesi.edu.co
</a>

<a href="https://github.com/eduard-martinez" style="color:black;"> <img src="pic/github.png" alt="Qries" width="20" height="20"/> eduard-martinez</a>

<a href="https://twitter.com/emartigo" style="color:black;"> <img src="pic/twitter.jpg" alt="Qries" width="20" height="20"/> @emartigo</a>

<a href="https://eduard-martinez.github.io" style="color:black;"> <img src="pic/link.png" alt="Qries" width="20" height="20"/> https://eduard-martinez.github.io</a>

# ¬øQu√© es una red?

En Business Analytics, una **red** (o *grafo*) es una representaci√≥n matem√°tica de las **relaciones** entre entidades:

- Cada **nodo (v√©rtice)** representa un agente: persona, empresa, producto, ciudad, etc.  
- Cada **arista (enlace)** representa una relaci√≥n o interacci√≥n entre ellos: amistad, transacci√≥n, flujo de informaci√≥n, etc.  

Las redes permiten analizar fen√≥menos donde la **interdependencia** entre unidades es clave:  

- Comunicaci√≥n dentro de una organizaci√≥n.  
- Recomendaciones de productos.  
- Flujos comerciales entre pa√≠ses.  
- Colaboraciones cient√≠ficas o empresariales.  

::: callout-note
**Idea clave:** Una red combina estructura (nodos y enlaces) y comportamiento (intensidad, direcci√≥n, frecuencia).  
:::

## Tipos de grafos

Los grafos se clasifican seg√∫n la naturaleza de las relaciones que representan.

### Grafo no dirigido
Las conexiones son **bidireccionales**: si A est√° conectado con B, entonces B tambi√©n lo est√° con A.  
üìò Ejemplo: amistad, coautor√≠a, colaboraci√≥n.

Matem√°ticamente:
$$A_{ij} = A_{ji}$$
donde $A_{ij}$ indica la existencia de un v√≠nculo entre los nodos *i* y *j*.

### Grafo dirigido (*d√≠grafo*)
Las conexiones tienen **direcci√≥n**, lo que permite identificar flujos o jerarqu√≠as.  
üìò Ejemplo: seguidores en redes sociales, flujo de informaci√≥n, pagos entre empresas.

$$A_{ij} \neq A_{ji}$$

Un enlace de *i* a *j* no implica necesariamente que exista el de *j* a *i*.

### Grafo ponderado
Cada arista tiene un **peso o intensidad** que mide la fuerza, frecuencia o costo de la relaci√≥n.  
üìò Ejemplo: n√∫mero de transacciones, horas de comunicaci√≥n, volumen comercial.

El grafo se define como:
$$G = (V, E, W)$$
donde $W$ es el conjunto de **pesos asociados a las aristas**.

## Representaci√≥n de una red

Existen tres formas comunes de representar una red:

1. **Lista de aristas (edge list):**
   Cada fila indica una conexi√≥n entre dos nodos:

   ```
   from   to   weight
   Ana   Beto    3
   Ana   Carla   1
   ```
   
2. **Matriz de adyacencia:**
   Matriz cuadrada $A$ donde $A_{ij} = 1$ si *i* est√° conectado con *j*, y 0 si no.

3. **Matriz de incidencia:**
   Representa qu√© aristas inciden en qu√© nodos, √∫til para c√°lculos estructurales.


## M√©tricas de an√°lisis de redes

El objetivo del an√°lisis de redes es **cuantificar la posici√≥n e importancia de los nodos** dentro de la estructura global.

### M√©tricas locales
Miden la **influencia inmediata** de un nodo dentro de su entorno cercano.

- **Grado de centralidad (Degree):**
  N√∫mero de conexiones directas que tiene un nodo.
  $$C_D(i) = \sum_j A_{ij}$$
  Cuanto mayor el grado, mayor la capacidad de interacci√≥n directa.

- **Centralidad de intermediaci√≥n (Betweenness):**
  Mide cu√°ntas veces un nodo act√∫a como **puente** en los caminos m√°s cortos entre otros nodos.
  $$C_B(i) = \sum_{s \neq i \neq t} \frac{\sigma_{st}(i)}{\sigma_{st}}$$
  donde $\sigma_{st}(i)$ es el n√∫mero de caminos m√≠nimos entre *s* y *t* que pasan por *i*.

### M√©tricas globales
Eval√∫an la posici√≥n de un nodo **respecto a toda la red**.

- **Centralidad de cercan√≠a (Closeness):**
  Indica qu√© tan r√°pido puede un nodo llegar a todos los dem√°s.
  $$C_C(i) = \frac{1}{\sum_j d(i,j)}$$
  donde $d(i,j)$ es la distancia m√°s corta entre *i* y *j*.

- **Centralidad de eigenvector:**
  Considera no solo el n√∫mero de conexiones, sino la **importancia de los nodos conectados**.
  $$C_E(i) = \frac{1}{\lambda} \sum_j A_{ij} C_E(j)$$
  donde $\lambda$ es el mayor valor propio de la matriz de adyacencia.

## Propiedades estructurales de la red

- **Distancia promedio:** n√∫mero medio de pasos que separa a dos nodos cualesquiera.  
- **Excentricidad:** distancia m√°xima de un nodo a cualquier otro.  
- **Di√°metro:** m√°xima excentricidad de la red (longitud del camino m√°s largo entre dos nodos).  
- **Densidad:** proporci√≥n de conexiones existentes sobre el total posible.  
  $$D = \frac{2E}{N(N-1)}$$
  donde $E$ es el n√∫mero de aristas y $N$ el n√∫mero de nodos.

## Comunidades y modularidad

Las **comunidades** son subconjuntos de nodos m√°s densamente conectados entre s√≠ que con el resto de la red.

- En `igraph`, pueden detectarse con algoritmos como:
  - `cluster_louvain()` (para grafos ponderados)
  - `cluster_walktrap()`
  - `cluster_fast_greedy()`

- La **modularidad (Q)** mide qu√© tan bien separadas est√°n esas comunidades:
  $$Q = \frac{1}{2m}\sum_{ij}\left[A_{ij} - \frac{k_i k_j}{2m}\right]\delta(c_i, c_j)$$
  donde $c_i$ es la comunidad del nodo *i*.

## Aplicaciones en Business Analytics

- **Redes sociales corporativas:** identificar l√≠deres informales o cuellos de botella en la comunicaci√≥n.  
- **Marketing:** descubrir influenciadores clave.  
- **Log√≠stica:** optimizar rutas o flujos de transporte.  
- **Finanzas:** mapear interdependencias entre bancos o cooperativas.  
- **Open Finance:** analizar relaciones entre clientes y productos financieros.  

::: callout-tip
**Resumen:** El an√°lisis de redes permite traducir interacciones en conocimiento estructural, identificando qui√©n influye, c√≥mo fluye la informaci√≥n y d√≥nde se forman comunidades dentro de un sistema.  
:::

---

# Aplicaci√≥n en R

Para ilustrar el an√°lisis de redes, construiremos un ejemplo con la red de pases de los jugadores de la Selecci√≥n Colombia durante un partido. Cada nodo representa a un jugador, y cada arista dirigida indica un pase de un jugador a otro. El peso de la arista refleja la cantidad de veces que ese pase se repiti√≥ a lo largo del partido.

A partir de esta red podemos responder preguntas como:

	‚Ä¢	¬øQu√© jugadores son los m√°s influyentes en la circulaci√≥n del bal√≥n?
	‚Ä¢	¬øExisten jugadores que act√∫an como puentes entre l√≠neas (defensa, medio y ataque)?
	‚Ä¢	¬øQu√© tan conectada es la red del equipo?

Este ejercicio nos permitir√° visualizar c√≥mo los patrones de interacci√≥n dentro del equipo pueden analizarse con las mismas herramientas que usamos para estudiar redes sociales, empresariales o financieras. En esencia, un equipo de f√∫tbol es tambi√©n un sistema de relaciones, donde la posici√≥n en la red revela liderazgo, dependencia y eficiencia colectiva.

::: callout-tip
**C√≥mo usar este material:** Puedes ejecutar los _chunks_ de R directamente en el navegador gracias a **webR** (seg√∫n tu `_quarto.yml`), sin instalar nada localmente.
:::

## Preparaci√≥n del entorno

El prop√≥sito de este bloque es asegurar un entorno limpio y reproducible. Primero, eliminamos objetos previos que puedan interferir con el an√°lisis. Despu√©s, cargamos los paquetes necesarios para manipulaci√≥n de datos, visualizaci√≥n, generaci√≥n de res√∫menes y ejecuci√≥n de K-means. Con esto, dejamos el entorno preparado para comenzar.

```{webr-r}
# Limpiar el entorno de trabajo
rm(list = ls())

# instalar
install.packages("ggraph")
install.packages("igraph")

# Cargar paquetes
library(tidyverse)   # Manipulaci√≥n y transformaci√≥n de datos
library(igraph)      # Construcci√≥n y an√°lisis de redes
library(ggraph)      # Visualizaci√≥n avanzada de grafos

# Fijar semilla para reproducibilidad
set.seed(123)
```

## Ingesta de datos (carga desde archivo o URL)

En esta secci√≥n realizamos la ingesta de datos, es decir, el proceso de cargar la base que utilizaremos para construir la red de pases de la Selecci√≥n Colombia. Cada fila de la base representa un pase realizado entre dos jugadores durante un partido, con informaci√≥n sobre qui√©n hizo el pase, a qui√©n se dirigi√≥ y cu√°ntas veces se repiti√≥ esa acci√≥n.

Esta estructura de datos nos permitir√° representar el flujo del bal√≥n como un grafo dirigido y ponderado, donde:

	‚Ä¢	Los nodos son los jugadores.
	‚Ä¢	Las aristas son los pases.
	‚Ä¢	El peso de la arista indica la frecuencia del pase.

```{webr-r}
#| warning: false
#| message: false

## generar los datos
source("https://raw.githubusercontent.com/ba-in-r/01-slides/main/week-11/data/week-11.r")

## chuequear objeto
sel_colombia
```

## Tipos de grafos


```{webr-r}
# Crear matriz de adyacencia ponderada
sel_colombia <- sel_colombia %>%
  pivot_wider(names_from = to, values_from = peso, values_fill = 0) %>%
  column_to_rownames("from") %>%
  as.matrix()

# Crear grafo no dirigido desde la matriz
no_dir_plot <- graph.adjacency(sel_colombia, mode = "undirected", diag = FALSE)

plot(no_dir_plot)
```

## Escalado

Antes de aplicar K-means es fundamental escalar las variables: transformarlas para que todas queden en la misma escala (media 0 y desviaci√≥n est√°ndar 1). Esto evita que una variable con valores naturalmente m√°s grandes (como tempo) domine el c√°lculo de distancias frente a otras en rangos m√°s peque√±os (como danceability).

Con la funci√≥n scale() se obtiene una matriz estandarizada lista para el an√°lisis. Posteriormente, se utiliza skim() para verificar de manera r√°pida la estructura de los datos escalados y confirmar que la transformaci√≥n se realiz√≥ correctamente.

```{webr-r}
## escalar
x <- scale(features)

## check data (skim)
skim(x)

## visualicemos las variables danceability y tempo
ggplot(data=x , aes(x=tempo , y=danceability)) +
geom_point()
```

## Ajuste de K-means con K = 4

En este bloque se realiza el entrenamiento del modelo K-means fijando el n√∫mero de clusters en k = 3. Primero, se establece una semilla aleatoria (set.seed(2024)) para asegurar que los resultados sean reproducibles, ya que K-means depende de inicializaciones aleatorias de los centroides.

Despu√©s, con la funci√≥n kmeans() se ajusta el modelo sobre la matriz estandarizada X, indicando centers = 4 para formar cuatro grupos. El argumento nstart = 30 hace que el algoritmo se ejecute 30 veces con diferentes inicializaciones y escoja la mejor soluci√≥n encontrada, reduciendo la posibilidad de caer en m√≠nimos locales.

El objeto resultante km contiene la informaci√≥n clave del modelo: asignaci√≥n de observaciones a clusters, coordenadas de los centroides y medidas de ajuste como la suma de cuadrados intra e inter-cluster.

```{webr-r}
## fijar semilla
set.seed(2024)

## ajustar modelo
km <- kmeans(x, centers = 4, nstart = 30)
```

En este bloque se realiza el ajuste final de K-means y el resumen de los clusters obtenidos. Primero, se crea un nuevo objeto spotify_c que a√±ade una columna llamada cluster, donde se almacena el resultado de la asignaci√≥n de cada observaci√≥n al grupo correspondiente (km$cluster). Esta columna se convierte en un factor para facilitar la interpretaci√≥n y las operaciones posteriores.

```{webr-r}
## Agregar variable de cluster
spotify_c <- spotify %>% 
             mutate(cluster = factor(km$cluster))

## head(spotify_c)
head(spotify_c)

## inspeccionar con tabla de frecuencias
table(spotify_c$cluster)
```

## Inspeccionar los clusters

```{webr-r}
## plot
ggplot(spotify_c, aes(x=tempo , y=danceability , color=cluster)) +
geom_point(alpha = 0.6) +
theme_minimal(base_size = 12)
```

## Heur√≠stica del codo

El m√©todo del codo es una t√©cnica pr√°ctica para determinar el n√∫mero apropiado de clusters k. Consiste en calcular la suma de cuadrados intra-cluster (WSS, within-cluster sum of squares) para distintos valores de k. A medida que aumenta el n√∫mero de clusters, el WSS disminuye (ya que los grupos se vuelven m√°s homog√©neos). Sin embargo, llega un punto en que la mejora se vuelve marginal: ese punto de inflexi√≥n, con forma de ‚Äúcodo‚Äù en la curva, sugiere el n√∫mero √≥ptimo de clusters.

```{webr-r}
## fijar semilla
set.seed(2024)

## numero de codos
ks <- 1:8
```

Aqu√≠ se calcula el WSS (suma de cuadrados intra-cluster) para cada valor de k definido anteriormente. Se utiliza un map_dbl() que ejecuta la funci√≥n kmeans() repetidamente, y para cada soluci√≥n obtiene el valor de tot.withinss. El argumento nstart = 20 indica que el algoritmo se ejecutar√° varias veces con diferentes inicializaciones para mejorar la estabilidad del resultado.

```{webr-r}
## wss
wss <- map_dbl(ks, ~ kmeans(x, centers = .x, nstart = 20)$tot.withinss)

## inspeccionar el objeto
head(wss)
```

Finalmente, se organiza la informaci√≥n en un tibble llamado elbow_df, que contiene dos columnas: el n√∫mero de clusters (k) y el valor correspondiente de WSS (wss). Esta tabla servir√° como insumo para construir el gr√°fico del codo y tomar una decisi√≥n sobre el n√∫mero √≥ptimo de clusters.

```{webr-r}
## elbow_df
elbow_df <- tibble(k = ks, wss = wss)

## inspeccionar el objeto
head(elbow_df)
```

En este bloque se construye el gr√°fico del codo, que permite visualizar c√≥mo var√≠a la suma de cuadrados intra-cluster (WSS) a medida que aumenta el n√∫mero de clusters k. Primero, se utiliza ggplot() para graficar el objeto elbow_df, que contiene los pares (k, wss) obtenidos en pasos anteriores. La funci√≥n geom_line() dibuja la l√≠nea que conecta los puntos, mientras que geom_point() resalta cada valor de k con un marcador. Los par√°metros de color (#0ea5e9) y grosor de l√≠nea (linewidth = 1) sirven para mejorar la est√©tica del gr√°fico.

Finalmente, se aplica theme_minimal() para una visualizaci√≥n limpia y labs() para asignar t√≠tulo y etiquetas a los ejes. El resultado es una curva decreciente donde se espera identificar un punto de inflexi√≥n: all√≠ se encuentra el ‚Äúcodo‚Äù, que sugiere un n√∫mero razonable de clusters para aplicar el algoritmo de K-means.

```{webr-r}
## plot data 
ggplot(elbow_df, aes(k, wss)) +
geom_line(color = "#0ea5e9", linewidth = 1) +
geom_point(color = "#0ea5e9", size = 2) +
theme_minimal(base_size = 12) +
labs(title = "Heur√≠stica del codo para elegir K",
     x = "N. de clusters (K)", y = "Suma intra-cluster (WSS)")
```

## Actividad en Clase

Instrucciones:

	1.	Ejecute los chunks de c√≥digo proporcionados en R.
	
	2.	Observe los resultados obtenidos (tablas resumen por cl√∫ster).
	
	3.	Genere un documento en Word donde:
	‚Ä¢	Copie las preguntas que aparecen a continuaci√≥n.
	‚Ä¢	Escriba sus interpretaciones y conclusiones con base en los resultados (no debe copiar el c√≥digo ni las tablas, solo redactar sus respuestas).
	
	4.	Suba su documento a la plataforma Intu.

```{webr-r}
## Streams (Reproducciones)
summarise(.data = spotify_c , mean(streams) , min(streams) , max(streams) , .by=cluster)

## Duraci√≥n
summarise(.data = spotify_c , median(duration_ms) , .by=cluster)

## Tempo y Danceability:
summarise(.data = spotify_c , mean(tempo) , mean(danceability) , .by=cluster)
```

Preguntas de interpretaci√≥n:

	1.	Streams (Reproducciones):
	‚Ä¢	Seg√∫n los promedios, m√≠nimos y m√°ximos de streams en cada cl√∫ster:
	‚Ä¢	¬øQu√© cluster contiene la canci√≥n m√°s escuchada?
	‚Ä¢	¬øEn promedio, qu√© cluster contiene las canci√≥nes m√°s escuchada?

	2.	Duraci√≥n: A partir de la mediana de duration_ms por cl√∫ster:
	‚Ä¢	¬øEn promedio, cu√°l cluster tiene canciones m√°s cortas?

	3.	Tempo y Danceability: Considerando el promedio de tempo y danceability por cl√∫ster:
	‚Ä¢	¬øQu√© cluster tiende a tener canciones con mayor energ√≠a r√≠tmica?
	‚Ä¢	¬øCu√°l agrupa canciones con menor ‚Äúbailabilidad‚Äù?
